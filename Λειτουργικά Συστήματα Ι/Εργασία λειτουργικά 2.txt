#
# Εργαστήριο ΛΣ 1 / Ασκηση 2 / 2020-21
# Ονοματεπώνυμο: ΤΣΕΤΣΩΝΗΣ ΓΕΩΡΓΙΟΣ
# ΑΜ: 19390236
#

#
# Ερώτηση 1:
# Να γραφτεί script με το όνομα searching το οποίο (α) να δέχεται ως ορίσματα δύο ακεραίους
# αριθμούς και (β) να ζητάει από το χρήστη το όνομα ενός καταλόγου, και με βάση αυτά να
# εμφανίζει στην οθόνη τα ακόλουθα (τα 1-3 με χρήση της εντολής find και τα 4-5 με συνδυασμό
# των εντολών ls και grep):
# 1. Τα αρχεία του δέντρου του δοθέντος καταλόγου με εξουσιοδοτήσεις (permissions) τον πρώτο
# αριθμό (όρισμα) θεωρώντας τον ως οκταδικό ισοδύναμο.
# 2. Τα αρχεία του δέντρου του δοθέντος καταλόγου που άλλαξαν (modify) περιεχόμενα κατά τις
# ‘x’ τελευταίες μέρες, όπου ‘x’ ο δεύτερος αριθμός (όρισμα).
# 3. Τους υποκαταλόγους του δέντρου του δοθέντος καταλόγου που προσπελάστηκαν (access)
# κατά τις ‘x’ τελευταίες μέρες, όπου ‘x’ ο δεύτερος αριθμός (όρισμα).
# 4. Τα αρχεία του δοθέντος καταλόγου στα οποία έχουν δικαίωμα ανάγνωσης όλοι οι χρήστες.
# 5. Τους υποκαταλόγους του δοθέντος καταλόγου στους οποίους έχουν δικαίωμα αλλαγών
# (create/rename/delete files) εκτός από τον ιδιοκτήτη και άλλοι χρήστες του συστήματος.
# Πριν από τον εκτύπωση κάθε λίστας από τις παραπάνω (1 έως 5) να τυπώνεται κατάλληλη
# επικεφαλίδα η οποία να αναφέρει μεταξύ άλλων και τον αριθμό των αρχείων (ή υποκαταλόγων)
# που πρόκειται να τυπωθούν. Το script να εκτελείται επαναληπτικά όσο επιθυμεί ο χρήστης (για
# διαφορετικούς καταλόγους) και στο τέλος (πριν την τελική έξοδο) να εμφανίζει αθροιστικά το
# συνολικό αριθμό των ευρεθέντων (αρχείων / υποκαταλόγων) κάθε περίπτωσης (από τις 1 έως 6)
# για όλους τους καταλόγους στους οποίους έψαξε.
#
# Απάντηση: Αρχικά, χρησιμοποιούμε την εντολή 'vi' ώστε να δημιουργήσουμε ένα script και αμέσως να γράψουμε σε αυτό.
# Ακολουθείται από την παράμετρο  'searching.sh' ώστε να δημιουργήσουμε script με το όνομα searching. Μέσα στο script
# όπως βλέπουμε χρησιμοποιούμε την εντολή 'echo' και εμφανίζουμε την τιμή της πρώτης και δεύτερης παραμέτρου. Με την
# χρήση της 'while' μπορούμε να εκτελούμε το script για όσα directory θέλουμε. Μέσα σε αυτήν δίνουμε το diractory που
# θέλουμε και στην συνέχεια μπαίνουμε σε αυτό. Πρώτα βρίσκουμε και εμφανίζουμε πόσα και ποιά αρχεία με εξουσιοδοτήσεις 
# το πρώτο όρισμα υπάρχουν με την εντολή 'find -perm -$1' όπου '-$1' είναι η τιμή τους πρώτου ορίσματος.Η παράμετρος 
# 'wc -l' εμφανίζει τον αριθμό αυτών των αρχείων. Στην συνέχεια βρίσκουμε τα αρχεία του που άλλαξαν περιεχόμενα κατά 
# τις ‘x’ τελευταίες μέρες, όπου ‘x’ το δεύτερο όρισμα, με την εντολή 'find -newermt "$2 days ago"'. Ακόμη, βρίσκουμε 
# τους υποκαταλόγους που προσπελάστηκαν κατά τις ‘x’ τελευταίες μέρες, όπου ‘x’ το δεύτερο όρισμα με την εντολή 
# 'find -atime -$2 -type f'. Τέλος, εμφανίζουμε τα αρχεία στα οποία έχουν δικαίωμα ανάγνωσης όλοι οι χρήστες και τους 
# υποκαταλόγους στους οποίους έχουν δικαίωμα αλλαγών εκτός από τον ιδιοκτήτη και άλλοι χρήστες του συστήματος με τις 
# εντολές 'ls -l | grep "^.......r"' και 'ls -l | grep "^..w..w..w."' αντιστοίχως. Εμφανίζοντας κατάλληλο μήνυμα δίνει 
# στον χρήστη επιλογή να τρέξει το script ξανά με τα ίδια ορίσματα αλλά για διαφορετικό diractory.
#

vi searching.sh
#!/bin/bash

echo "First argument: "$1
echo "Second argument: "$2
echo ""


while true; 
do
read -p "Enter a diractory name: " name
cd ~/$name
echo ""
echo "specific permissions"
find -perm -$1 | wc -l
find -perm -$1


echo ""
echo "Last modified "
find -newermt "$2 days ago" | wc -l
find -newermt "$2 days ago"


echo ""
echo "Last accessed"
find -atime -$2 -type f | wc -l
find -atime -$2 -type f


echo ""
echo "Read permission"
ls -l | grep "^.......r" | wc -l
ls -l | grep "^.......r"


echo ""
echo "create/rename/delete permission by all"
ls -l | grep "^..w..w..w." | wc -l
ls -l | grep "^..w..w..w."
read -p "Test another diractory (Y/N)?" continue
case "$continue" in
  N*|n*) break;;
  *) continue;;
esac
done


#
# Ερώτηση 2:
# Να γραφτεί script με το όνομα teldb το οποίο θα διαχειρίζεται μία βάση τηλεφωνικού καταλόγου
# η οποία θα υλοποιείται στο αρχείο catalog. Το script θα πρέπει να κάνει τα εξής:
# - Με την παράμετρο –a θα προσθέτει μια νέα εγγραφή στον κατάλογο (δηλαδή στο αρχείο
# catalog). Η προσθήκη θα γίνεται αφού ζητήσει από τον χρήστη όνομα, επώνυμο, πόλη και η
# καταχώρηση θα τοποθετείται σε μία γραμμή (π.χ. John Markou Peristeri 2105546789).
# - Με την επιλογή –l θα μας δείχνει τα περιεχόμενα του καταλόγου (με αριθμημένες τις γραμμές
# του και παραλείποντας τις τυχόν κενές γραμμές).
# - Με την επιλογή –s ακολουθούμενη από έναν αριθμό θα μας δείχνει τα περιεχόμενα του
# καταλόγου ταξινομημένα κατά τη στήλη που δηλώνει ο αριθμός (π.χ. το telcat –s 3 θα
# εμφανίζει τα περιεχόμενα ταξινομημένα κατά πόλη).
# - Με την επιλογή –c ακολουθούμενη από ένα keyword θα μας εμφανίζει μόνο τις γραμμές του
# καταλόγου που περιλαμβάνουν το keyword.
# - Με την επιλογή –d ακολουθούμενη από ένα keyword και –b ή –r, θα διαγράφει τις γραμμές
# του καταλόγου που περιλαμβάνουν το keyword. Αν η τρίτη παράμετρος είναι –b θα εισάγει
# στη θέση κάθε γραμμής που διαγράφει μία κενή ειδάλλως (–r) όχι .
# - Με την επιλογή –n θα εμφανίζει τον αριθμό των κενών γραμμών του καταλόγου, θα ζητάει
# από το χρήστη αν θέλει να διαγραφούν ή όχι και θα πράττει ανάλογα.
# Σε κάθε άλλη περίπτωση θα τυπώνεται το κατάλληλο μήνυμα χρήσης/καθοδήγησης (Usage).
# Επίσης αν στις παραμέτρους –c και –d δεν υπάρχουν γραμμές που να περιλαμβάνουν το keyword
# ο χρήστης να ειδοποιείται με το κατάλληλο μήνυμα.
#
# Απάντηση: Αρχικά, χρησιμοποιούμε την εντολή 'vi' ώστε να δημιουργήσουμε ένα script και αμέσως να γράψουμε σε αυτό.
# Ακολουθείται από την παράμετρο  'teldb.sh' ώστε να δημιουργήσουμε script με το όνομα teldb. Δημιουργούμε ένα αρχείο 
# txt με όνομα catalog και με την χρήση της 'case' θα εκτελούνται εντολές ανάλογα με το όρισμα που θα δίνεται όταν 
# καλείται το script. Στην περίπτωση του ορίσματος '-a' θα προσθέτει μια νέα εγγραφή αφού πρώτα έχουν ζητηθεί από
# τον χρήστη τα κατάλληλα στοιχεία. Με το όρισμα '-l' θα δείχνει τα περιεχόμενα του καταλόγου με αριθμημένες γραμμές.
# Με το όρισμα '-s' ακολουθούμενο από έναν αριθμό δείχνει τα περιεχόμενα του καταλόγου ταξινομημένα κατά τη στήλη που 
# δηλώνει ο αριθμός. Αυτό γίνεται με την εντολή 'sort -t" " -k$2 catalog.txt' όπου $2 είναι ο αριθμός που έχει δοθεί ως
# όρισμα. Με το όρισμα '-c' ακολουθούμενο από ένα keyword και διαγράφει τις γραμμές του καταλόγου που περιλαμβάνουν το keyword. 
# Αυτό γίνεται με την χρήση της 'grep'. Με το όρισμα '-n' εμφανίζει τον αριθμό των κενών γραμμών του καταλόγου πάλι με την 'grep'.
# Επίσης, ζητάει από τον χρήστη αν θέλει να διαγραφούν ή όχι. Η διαγραφή των γραμμών γίνεται με την εντολή 'sed'.
#

vi teldb.sh
#!/bin/bash

touch catalog.txt
  case $1 in
    "-a")
      echo "new entry"
      echo "Write the name:"
      read name
      echo "Write the surname:"
      read surname
      echo "Write the town:"
      read town
      echo "Write the number:"
      read number
      echo "$name $surname $town $number" >> catalog.txt
      ;;
    "-l")
      echo "show details"
      nl -bt catalog.txt
      ;;
    "-s")
      echo "sorted details"
      sort -t" " -k$2 catalog.txt
      ;;
    "-c")
      echo "keyword"
      grep [$2] catalog.txt
      ;;
    "-d")
      echo "delete lines"
      grep -v $2 catalog.txt 
      ;;
    "-n")
      echo "show spaced lines"
      grep -cvP '\S' catalog.txt
      while true;
      do
      read -p "Do you want to delete all blank lines?(Y/N)" continue
      case "$continue" in
        Y* | y*)
        sed -r '/^\s*$/d' catalog.txt
        break;;
        N* | n*) 
        break;;
        *)continue;;
      esac
      done
      ;;
  esac


#
# Ερώτηση 3:
# Σε μια εφαρμογή χρειάζεται να δημιουργούμε νέους καταλόγους τους οποίους θα βρίσκει και θα
# χρησιμοποιεί. Γράψτε ένα script με όνομα createpvs το οποίο θα καλείται με παραμέτρους
# ROOTFOLDER, no_of_DBFOLDERS, no_of_DATAFOLDERS, USERNAME π.χ.
# createpvs /etc/data 0 5 user555
# το οποίο θα κάνει τα ακόλουθα:
#  Θα ελέγχει τον αριθμό των ορισμάτων ώστε να είναι 4
#  Θα ελέγχει αν υπάρχει ο ROOTFOLDER μέσα στον οποίο θα δημιουργηθούν οι νέοι
# κατάλογοι
#  Θα ελέγχει αν υπάρχει ο χρήστης USERNAME (μέσα στο αρχείο /etc/passwd)
#  Αν όλοι οι έλεγχοι είναι επιτυχείς,
# - Θα δημιουργεί τόσους υποφακέλους με όνομα dbfolderΝ μέσα στον ROOTFOLDER
# όσους υποδεικνύει το νούμερο no_of_DBFOLDERS και με τέτοιο τρόπο ώστε να μην
# κάνει “overwrite” υφιστάμενους φακέλους. Π.χ. αν ο τελευταίος φάκελος που είχε
# δημιουργηθεί από προηγούμενη εκτέλεση είναι ο dbfolder18 και θέλουμε 6 νέους, θα
# πρέπει να δημιουργήσει τους dbfolder19, dbfolder20,…,dbfolder24 (αν η παράμετρος
# είναι 0 δεν θα πρέπει να δημιουργήσει κανέναν).
# - To ίδιο θα πρέπει να ισχύει (δηλαδή να δημιουργούνται χωρίς “overwrite”) και για τους
# υποφακέλους datafolderN που καθορίζονται από το no_of_DATAFOLDERS.
# - Μετά την δημιουργία των φακέλων, θα χρησιμοποιεί την εντολή chown ώστε να δώσει
# την κυριότητα των νέων φακέλων στον χρήστη USERNAME.
#
# Απάντηση: Αρχικά, χρησιμοποιούμε την εντολή 'vi' ώστε να δημιουργήσουμε ένα script και αμέσως να γράψουμε σε αυτό.
# Ακολουθείται από την παράμετρο  'createpvs.sh' ώστε να δημιουργήσουμε script με το όνομα createpvs. Μετά από κατάλληλους 
# ελέγχους για τον αριθμό των ορισμάτων, τη ύπαρξη του ROOTFOLDER και την ύπαρξη του χρήστη προχωράμε στα υπόλοιπα 
# ζητούμενα. Σε αντίθετη περίπτωση το script δεν εκτελείται ολόκληρο και σταματάει μετά τους ελέγχους. Αφού όλοι ελέγχοι
# είναι επιτυχείς μπαίνουμε στον ROOTFOLDER με την εντολή 'cd' και δημιουργούμε τόσους υποφακέλους με όνομα dbfolderΝ 
# όσους υποδεικνύει το δεύτερο όρισμα με την εντολή 'mkdir'. Ομοίως πράττουμε για τους υποφακέλους datafolderN αλλά
# αυτή τη φορά με βάση το τρίτο όρισμα. Αφου δημιουργούμε τα παραπάνω με την εντολή 'sudo chown $4:$4' ακολουθούμενη
# από το όνομά τους δίνει την κυριότητα των νέων φακέλων στον χρήστη που έχει δοθεί ως τέταρτο όρισμα.
#

vi createpvs.sh
#!/bin/bash

 if [ "$#" -ne 4 ]; 
 then
   echo "You must enter exactly 4 arguments" >&2
   exit 1
 fi
 echo $# "arguments"


 if [ -d $1 ]
 then
   echo "Directory " $1 " exists"
 else 
   echo "Error: Directory " $1 " does not exists" >&2
   exit 1
 fi


 getent passwd $4 > /dev/null 2&>1
 if [ $? -eq 0 ]; then
  echo "The user " $4 " exists"
 else
  echo "The user " $4 " does not exist" >&2
  exit 1
 fi
 

 cd $1
 for (( i=1;i<=$2;i++)) 
 do
 mkdir dbfolder$i
 sudo chown $4:$4 dbfolder$i
 done


 for (( i=1;i<=$3;i++)) 
 do
 mkdir datafolder$i
 sudo chown $4:$4 datafolder$i
 done


#
# Ερώτηση 4:
# Γράψτε ένα script με όνομα bck το οποίο θα κρατά για έναν συγκεκριμένο χρήστη (το user name
# του οποίου θα δίνεται ως πρώτο όρισμα) εφεδρικά αντίγραφα μιας περιοχής του λογαριασμού του
# σε κάποια άλλη. Το script θα πρέπει να δέχεται ως δεύτερο όρισμα ένα κατάλογο (ή αρχείο), να
# δημιουργεί ένα προς αποθήκευση αντίγραφο του ορίσματος (χρήση tar) και να το αντιγράφει
# στον κατάλογο που ορίζει το τρίτο όρισμα. Αν ωστόσο το τρίτο όρισμα είναι αρχείο (και όχι
# κατάλογος) τότε θα πρέπει απλά να προσθέτει (append) το προς αποθήκευση αντίγραφο στο
# αρχείο αυτό. Κάντε τους απαραίτητους ελέγχους και για τα τρία ορίσματα (καθώς και για το
# συνολικό αριθμό των ορισμάτων που δόθηκαν κατά την εκτέλεση).
# Τροποποιήστε κατάλληλα το script bck (σε bck1) ώστε να πραγματοποιεί το ζητούμενο backup
# προγραμματισμένα (χρήση at), σε μια συγκεκριμένη ώρα της επιλογής σας (προσπαθήστε να τη
# δίνετε και αυτήν σαν όρισμα).
# Τροποποιήστε κατάλληλα το script bck (σε bck2) ώστε να εκτελείται χωρίς ορίσματα και απλά
# να λαμβάνει αντίγραφο του καταλόγου εργασίας σας στο /tmp, και προγραμματίστε (χρήση cron)
# να τρέχει κάθε Κυριακή βράδυ στις 11μμ. για τους επόμενους έξι μήνες.
#
# Απάντηση: Αρχικά, χρησιμοποιούμε την εντολή 'vi' ώστε να δημιουργήσουμε ένα script και αμέσως να γράψουμε σε αυτό.
# Ακολουθείται από την παράμετρο  'bck.sh' ώστε να δημιουργήσουμε script με το όνομα bck. Αρχικά, γίνεται έλεγχος για 
# τον αριθμό των ορισμάτων έτσι ώστε αν δεν είναι τρία να μην εκτελείται το script. Σε αντίθετη περίπτωση ελέγχεται 
# αν το δεύτερο όρισμα είναι directory ή file. Αν είναι directory τυπώνει κατάλληλο μήνυμα και δημιουργεί ένα
# αντίγραφο με την εντολή 'tar cvf'. Στην συνέχεια γίνεται έλεγχος για το αν το τρίτο όρισμα είναι diractory ώστε
# να μεταφερθεί εκεί το αντίγραφο. Ωστόσο, αν το δεύτερο όρισμα είναι file τότε κάνουμε τα ίδια βήματα με πριν.
# Σε περίπτωση που το δεύτερο όρισμα δεν είναι ούτε diractory ούτε file τότε το script σταματάει και τυπώνει 
# κατάλληλο μήνυμα.
#

vi bck.sh
#!/bin/bash

if [ "$#" -ne 3 ]; 
 then
   echo "You must enter exactly 3 arguments" >&2
   exit 1
fi
echo $# "arguments"
 
if [[ -d $2 ]]; then
 echo "$2 is a directory"
 tar cvf Copy$2.tar $2
 if [[ -d $3 ]]; then
  echo "$3 is a directory"
  tar xvf Copy$2.tar -C $3
  else
  echo "$3 is not valid"
  exit 1
  fi
elif [[ -f $2 ]]; then
 echo "$2 is a file"
 tar cvf Copy$2.tar $2
  if [[ -d $3 ]]; then
  echo "$3 is a directory"
  tar xvf Copy$2.tar -C $3
  elif [[ -f $2 ]]; then
  echo "$3 is a file"
  cat $2 > $3
  else
  echo "$3 is not valid"
  exit 1
  fi
else
 echo "$2 is not valid"
 exit 1
fi


#
# Ερώτηση 5:
# Γράψτε ένα script, με όνομα mfproc και δυνατότητα εισαγωγής 0, 1 ή 2 παραμέτρων ως εξής:
# Ονομα
# mfproc Εμφανίζει πληροφορίες για διεργασίες με την εξής μορφή:
# Name PID PPID UID GID State
# Συνοπτικά
# mfproc [-u username] [-s S|R|Z]
# -u username Ορίζει τον χρήστη του οποίου τις διεργασίες πρέπει να εμφανίσετε στο standard
# output. Αν δεν δοθεί, θα εμφανίσετε όλες τις διεργασίες του ΛΣ
# -s state Ορίζει την κατάσταση των διεργασιών που πρέπει να εμφανίσετε στο standard
# output. Μπορεί να είναι οτιδήποτε μεταξύ των Running(R), Sleeping (S), Zombie
# (Z). Αν δεν δοθεί, τότε θα εμφανίσετε όλες τις διεργασίες που βρίσκονται σε οποιαδήποτε από
# τις τρεις καταστάσεις
# Επιστρεφόμενη τιμή
# 0 Δεν υπήρξε λάθος
# 1 Δεν υπάρχει ο χρήστης
# 2 Δεν υπάρχει διεργασία σε αυτή την κατάσταση
# Σημείωση: Στο κατάλογο proc του ΛΣ, πέραν των άλλων, υπάρχουν κατάλογοι με όνομα τον
# αριθμό οποιασδήποτε διεργασίας του ΛΣ. Πιο συγκεκριμένα θα πρέπει να χρησιμοποιήσετε το
# αρχείο status του καταλόγου /proc/<PID>/status. Κείμενο επεξήγησης για το αρχείο
# στατιστικών /proc/<PID>/status: Table 1-2: Contents of the status files του συνδέσμου
# https://www.kernel.org/doc/Documentation/filesystems/proc.txt
#
# Απάντηση: Αρχικά, χρησιμοποιούμε την εντολή 'vi' ώστε να δημιουργήσουμε ένα script και αμέσως να γράψουμε σε αυτό.
# Ακολουθείται από την παράμετρο  'mfproc.sh' ώστε να δημιουργήσουμε script με το όνομα mfproc. Αρχικά, γίνεται 
# έλεγχος ώστε να δωθούν έως δύο ορίσματα. Με την εντολή 'ps $1 -o' εμφανίζει τις διεργασίες του ΛΣ με την σειρά
# Name PID PPID UID GID State
#

vi mfproc.sh
#!/bin/bash

if [ "$#" -gt 2 ]; 
 then
   echo "You must enter up to 2 arguments" >&2
   exit 1
fi
echo $# "arguments"

ps $1 -o user,pid,ppid,uid,gid,state