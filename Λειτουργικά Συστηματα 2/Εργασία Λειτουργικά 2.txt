#
#ΕΡΓΑΣΤΗΡΙΟ ΛΣ 2 / ΑΣΚΗΣΗ 1 / 2023-24
#Ονοματεπώνυμο"Φιλιππός Παπαγεωργίου
#ΑΜ:21390174
#
#
#ΑΣΚΗΣΗ 1:
#1. Έστω ένα πρόγραμμα σε C στην αρχή του οποίου δίνονται οι εξής εντολές:
#pid1=fork();
i#f (pid1!=0) { pid2=fork(); pid3=fork(); }
#else { pid4=fork(); if (pid4==0) { pid5=fork(); } }
#..............................
#Πόσες διεργασίες παράχθηκαν με τις προηγούμενες εντολές; Ποια είναι η «συγγένεια» μεταξύ τους; Εξηγείστε
#συνοπτικά πως παρήχθησαν οι ανωτέρω διεργασίες (βήμα/εντολή προς βήμα/εντολή, με ποιο fork δημιουργήθηκε η
#κάθε μία / ποιο pid αντιστοιχεί σε κάθε μία κλπ). Δώστε επίσης ένα σχήμα στο οποίο θα φαίνεται με σαφή τρόπο η
#ιεραρχία μεταξύ των ανωτέρω διεργασιών. 
#
#Εξήση παραπάνω κώδικα
#Παραχθήκαν συνολό 6 διεργασίες.Η πρώτη διεργασία(γονέας) καλεί την κλήση συστηματός fork(),η οποια σημιουργεί ένα αντιγραφό 
#του εαυτού της.Η επιστρεφόμενη τιμή της fork() αποθυκεύτεαι στην pid1.Σε αυτό το σημείο, υπαρχούν 2 πανομοιότυπες διεργασίες που εκτελούνται 
#παράλληλα.Η μια είναι η γονική διεργασία και η άλλη η διεργασία-παιδί.Η γονική διεργασία συνεχίζει την εκτέλεση της επομενης γραμμής,
#η οποια είναι μιια δήλωση if.Η συνθήκη pid1!=0 είναι αληθής για τη γονική διεργασία ,όποτε εισέρχεται στο μπλοκ κώδικα μέσα στις ακγύλες.
#Η γονική διεργασία καλέι την fork() αλλές δύο φορές η οποία δημιιουργεί δύο νέες διεργασίες-παίδια.Οι επιστρεφόμενες τιμές αποθυκεύονται στις 
#pid2 και pid3.Σε αυτό το σημείο υπαρχούν 4 διεργασίες που εκτελούνται παράλληλα.
#Για κάθε μια άπο τις διεργασίες-παιδία που δημιουργήθηκαν στο βήμα 3 συνεχίζει επισής την εκτέλεση της επομενης γραμμής η οποία είναι η κλήση συστηματός
#fork().Ωστόσο δεν εισέρχεταιστο μπλοκ κώδικα if .Αντί αυτού καλούν την fork() μια μόνο φορά η οποία   δημιουργεί δύο άκομα διεργασίες-παιδία 
# Η επιστρεφόμενητιμή της fork() αποθυκεύεται στην pid4 για τη διεργασί-παιδί και στην pid5 για την άλλη.
#
#Σχήμα απεικόνισης:
            p
           / \
          /   \
         /     \
     pid1     p
       /|\     / \
      / | \   /   \
     /  |  \ /     \
pid2,pid3,pid4 pid5 
#Σε αυτό το διάγραμμα, η p αντιπροσωπεύει τη γονική διεργασία, η pid1 
#αντιπροσωπεύει τη διεργασία-παιδί που δημιουργήθηκε από την πρώτη fork(), οι pid2 και pid3
# αντιπροσωπεύουν τις διεργασίες-παιδιά που δημιουργήθηκαν από τη δεύτερη fork() στη γονική διεργασία και οι pid4 και
# pid5 αντιπροσωπεύουν τις διεργασίες-παιδιά που δημιουργήθηκαν από τη δεύτερη fork() στη C1. Τα βέλη υποδεικνύουν την κατεύθυνση της εκτέλεσης.
#Κώδικάς για το παραπάνωδιάγραμμα:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid1, pid2, pid3, pid4, pid5, pid6;
    
    // δημιουργο παιδί (pid1)
    pid1 = fork();
    
    if (pid1 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    else if (pid1 == 0) {
        // Πρώτο παιδι (pid1)
        printf("pid1 (child of P0): %d\n", getpid());
        
        // αριστέρο παιδί του  pid1(pid3)
        pid3 = fork();
        
        if (pid3 == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid3 == 0) {
            printf("pid3 (child of P1): %d\n", getpid());
            exit(EXIT_SUCCESS);
        }
        else {
            // Δημιουργώ δεξί παιδί (pid4)
            pid4 = fork();
            
            if (pid4 == -1) {
                perror("fork");
                exit(EXIT_FAILURE);
            }
            else if (pid4 == 0) {
                printf("pid4 (child of P1): %d\n", getpid());
                exit(EXIT_SUCCESS);
            }
            
            //Εδώ περιμένει το παιδί pid1 να τελίωσουυν οι διεργασίες παιδία τους
            wait(NULL);
            wait(NULL);
            exit(EXIT_SUCCESS);
        }
    }
    else {
        // Δημιουργοθμε δεξί παιδί(pid2)
        pid2 = fork();
        
        if (pid2 == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid2 == 0) {
            printf("pid2 (child of P0): %d\n", getpid());
            
            //Δημιουργό αριστέρο παιδί(pid5)
            pid5 = fork();
            
            if (pid5 == -1) {
                perror("fork");
                exit(EXIT_FAILURE);
            }
            else if (pid5 == 0) {
  
                printf("pid5 (child of P2): %d\n", getpid());
                exit(EXIT_SUCCESS);
            }
            else {
                pid6 = fork();
                
                if (pid6 == -1) {
                    perror("fork");
                    exit(EXIT_FAILURE);
                }
                else if (pid6 == 0) {
                    printf("pid6 (child of P2): %d\n", getpid());
                    exit(EXIT_SUCCESS);
                }
                wait(NULL);
                wait(NULL);
                exit(EXIT_SUCCESS);
            }
        }
        wait(NULL);
        wait(NULL);
        exit(EXIT_SUCCESS);
    }
}

#Σχολιασμός προγράμματος:
#Αυτό είναι ένα πρόγραμμα C που δημιουργεί μια δενδροειδή ιεραρχία διεργασιών χρησιμοποιώντας την κλήση συστήματος fork(). 
#Το πρόγραμμα ξεκινά με τη δημιουργία της αρχικής γονικής διεργασίας P0, η οποία στη συνέχεια δημιουργεί δύο διεργασίες-
#παιδιά pid1 και pid2. Καθεμία από αυτές τις διεργασίες-παιδιά δημιουργεί στη συνέχεια άλλες δύο διεργασίες-παιδιά, με αποτέλεσμα ένα δέντρο με συνολικά έξι διεργασίες.
#Η διεργασία P0 δημιουργεί τις διεργασίες pid1 και pid2 και στη συνέχεια περιμένει να τελειώσουν 
#χρησιμοποιώντας την κλήση συστήματος wait(). Η pid1 δημιουργεί δύο διεργασίες-παιδιά, τις pid3 και pid4,
#και περιμένει επίσης να τελειώσουν χρησιμοποιώντας την wait(). Η pid2 δημιουργεί δύο διεργασίες-παιδιά, τις pid5 και pid6, και περιμένει και αυτές να τελειώσουν.
#Παραλλάγη κώδικα με τα παραπάνω ερωτ'ηματα:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid1, pid2, pid3, pid4, pid5, pid6;
    int fd[2];
    // δημιουργο παιδί (pid1)
    pid1 = fork();

    if(pipe(fd)==-1){
    	perror("pipr");
    	exit(EXIT_FAILURE);
    }
    
    
    if (pid1 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    else if (pid1 == 0) {
        // Πρώτο παιδι (pid1)
        printf("pid1 (child of P0): %d\n", getpid());
        
        // αριστέρο παιδί του  pid1(pid3)
        pid3 = fork();
        
        if (pid3 == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid3 == 0) {
            // Αριστερό παίδι του pid1 (pid3)
            printf("pid3 (child of P1): %d\n", getpid());
            char message[10];
            read(fd[0], message, 10); // Διαβάζει μύνημα άπο το παιδί
            printf("P1 received message from P3: %s\n", message);
            exit(EXIT_SUCCESS);
        }
        else {
            // Δημιουργώ δεξί παιδί (pid4)
            pid4 = fork();
            
            if (pid4 == -1) {
                perror("fork");
                exit(EXIT_FAILURE);
            }
            else if (pid4 == 0) {
                printf("pid4 (child of P1): %d\n", getpid());
                exit(EXIT_SUCCESS);
            }
            
            //Εδώ περιμένει το παιδί pid1 να τελίωσουυν οι διεργασίες παιδία τους
            int status;
            pid_t wpid = waitpid(pid4, &status, 0); // Eδώ περιμένει το pid4 να τελιώσει
            printf("P1 received exit value from P4: %d\n", WEXITSTATUS(status));
            exit(EXIT_SUCCESS);
        }
    }
    else {
        // Δημιουργοθμε δεξί παιδί(pid2)
        pid2 = fork();
        
        if (pid2 == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid2 == 0) {
            printf("pid2 (child of P0): %d\n", getpid());
            
            //Δημιουργό αριστέρο παιδί(pid5)
            pid5 = fork();
            
            if (pid5 == -1) {
                perror("fork");
                exit(EXIT_FAILURE);
            }
            else if (pid5 == 0) {
  
                printf("pid5 (child of P2): %d\n", getpid());
                exit(EXIT_SUCCESS);
            }
            else {
                pid6 = fork();
                
                if (pid6 == -1) {
                    perror("fork");
                    exit(EXIT_FAILURE);
                }
                else if (pid6 == 0) {
                    printf("pid6 (child of P2): %d\n", getpid());
                    exit(EXIT_SUCCESS);
                }
                // Αυτή είναι ακόμα η pid2, περιμένοντας να τελειώσουν οι διεργασίες-παιδιά της
                int status;
                pid_t wpid = wait(&status); // Περιμένει να τελίωει οποιοδήποτε παίδι πρώτο
                printf("P2 received exit value from %d: %d\n", wpid, WEXITSTATUS(status));
                exit(EXIT_SUCCESS);
            }
        }
        wait(NULL);
        wait(NULL);
        exit(EXIT_SUCCESS);
    }
}

#Το μέρος (β) απαιτεί από τη διεργασία P1 να περιμένει ένα μήνυμα από τη διεργασία-παιδί P3 πριν συνεχίσει 
#την εκτέλεση. Μόλις λάβει το μήνυμα "hello" από την P3, θα πρέπει να το εκτυπώσει στην οθόνη. Στη συνέχεια
#, θα πρέπει να περιμένει την ολοκλήρωση της διεργασίας P4 και να εκτυπώσει την τιμή εξόδου της.
#Για να επιτύχουμε την επικοινωνία μεταξύ των διεργασιών γονέα και παιδιού στο μέρος (β),
#πρέπει να προσθέσουμε έναν κώδικα μπλοκ pipe για να περάσουμε το μήνυμα "hello" από την P3 στην P1.
#Ένας κώδικας μπλοκ pipe επιτρέπει την επικοινωνία μεταξύ δύο διεργασιών. Η συνάρτηση pipe δημιουργεί ένα 
#μονόδρομο κανάλι επικοινωνίας που επιτρέπει σε μια διεργασία να στέλνει δεδομένα σε μια άλλη διεργασία. 
#Σε αυτή την περίπτωση, μπορούμε να δημιουργήσουμε έναν σωλήνα μεταξύ των P1 και P3 για να στείλουμε το μήνυμα "hello".

#Το μέρος (γ) απαιτεί από τη διεργασία P2 να περιμένει την ολοκλήρωση ενός από τα παιδιά της, είτε της P5 είτε της P6. 
#Μόλις ολοκληρωθεί μια διεργασία-παιδί, η P2 θα πρέπει να εκτυπώσει το PID της διεργασίας-παιδιού που ολοκληρώθηκε.


#Επεκτείνατε επίσης το πρόγραμμά σας έτσι ώστε η διεργασία P2 να δημιουργεί Ν διεργασίες/άμεσα παιδιά (αντί για
#τις δύο μόνο διεργασίες/άμεσα παιδιά P5,P6 που φαίνεται να δημιουργεί στο παραπάνω σχήμα), όπου το N θα
#δίνεται από το χρήστη. Κάθε μία από τις Ν διεργασίες που θα δημιουργηθούν θα πρέπει να τυπώνει απλά ένα
#διαγνωστικό μήνυμα με το PID της και το PPID της και να τερματίζε

    pid_t  pid2;
    int num_procs;
    
    printf("Enter the number of child processes for P2: ");
    scanf("%d", &num_procs);

    pid2 = fork();
    
    if (pid2 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    else if (pid2 == 0) {
        // Δεξί παίδι του  P0 (pid2)
        printf("pid2 (child of P0): %d\n", getpid());
        
        for (int i = 1; i <= num_procs; i++) {
            pid_t pid = fork();
            
            if (pid == -1) {
                perror("fork");
                exit(EXIT_FAILURE);
            }
            else if (pid == 0) {
                // Αυτο είναι το παίδι που μόλισ φτιαχτικέ του P2
                printf("pid%d (child of P2): %d, PPID: %d\n", i+4, getpid(), getppid());
                exit(EXIT_SUCCESS);
            }
        }
        
        // Περιμένει οποιοδήποτε διεργασία-παιδί να τελιώσει για να συνεσίζει
        pid_t finished_child = wait(NULL);
        printf("P2: child process %d has finished.\n", finished_child);
        
        exit(EXIT_SUCCESS);
    }
	

#Αυτή η έκδοση του προγράμματος ζητάει από το χρήστη να εισάγει τον αριθμό των άμεσων διεργασιών-παιδιών που πρέπει να δημιουργήσει το P2 και στη συνέχεια 
#χρησιμοποιεί έναν βρόχο for για να δημιουργήσει τόσες διεργασίες-παιδιά.
# Κάθε διεργασία-παιδί εκτυπώνει τα δικά της PID και PPID και στη συνέχεια τερματίζει.
#Η μητρική διεργασία P2 περιμένει να τελειώσει οποιαδήποτε διεργασία-παιδί χρησιμοποιώντας τη συνάρτηση wait και εκτυπώνει το PID της 
#διεργασίας-παιδιού που τελείωσε. Σημειώστε ότι χρειάζεται να περιμένουμε μόνο μία
# διεργασία-παιδί να τελειώσει, αφού η P2 θα τερματίσει μόλις τερματίσουν όλες οι άμεσες διεργασίες-παιδιά της.	
 
#ΤΟ ΟΛΟΚΛΗΡΟΜΈΝΟ ΠΡΌΓΡΑΜΜΑ ΘΑ ΕΊΝΑΙ ΣΕ Ε´ΝΑ C FILE ΜΕΣΑ ΣΤΟ ZIP ΤΗΣ ΕΡΓΑΣΊΑ!Σ